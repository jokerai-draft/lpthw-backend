
从使用方的角度谈谈对于状态管理的期待

- 使用方
- 状态提供方

使用方负责接收按钮所触发的动作, 然后就是来回扫描状态的最新值 扫描最新状态

状态提供方自我更新状态

使用方根据状态提供方的最新状态 决定 1 跳转 2 打印 log 3 渲染页面
使用方如果渲染页面，那么就为页面提供单独的 databag (页面变量提供者 和 页面) 完全是单独机制在运作 (在必要情况下, databag['key'] = state['someState']; 这样的交接过程 彻底阻断了状态管理器干扰页面渲染的可能性)

一个载入式启动器
- 一个载入页
- 零个或一个状态提供方
- 一个或多个渲染安排
- 零个或多个按钮触发监听器
- 零次或一次 页面变量提供交接过程

- 无数次扫描最新状态, 但取最后一次 作为页面变量提供的素材
- 无数次状态的自我更新, 根据某个传入值进行状态管理 进行状态的自我更新




参考
状态提供方 最后可能会成为 model, 增加的状态管理的规模, 但状态管理的方式并未改变
"规模" 可以承载大规模的状态管理, 无论是否有 model
单次处理机制是明确的
在状态自我更新之后, 有不断不断扫描 by 使用方

